/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 boombox.glb -t 
*/

import * as THREE from "three";
import React, { useEffect, useRef, useState } from "react";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { ThreeEvent, useFrame } from "@react-three/fiber";
import {
  cursorActiveHandler,
  cursorInactiveHandler,
} from "Components/UserInterface/CursorOverlay";
import swal from "sweetalert";

type GLTFResult = GLTF & {
  nodes: {
    Cube_1: THREE.Mesh;
    Cube_2: THREE.Mesh;
    Cube_3: THREE.Mesh;
    Cube_4: THREE.Mesh;
    Cube_5: THREE.Mesh;
    Circle: THREE.Mesh;
    Circle_1: THREE.Mesh;
    Circle_2: THREE.Mesh;
    Cylinder: THREE.Mesh;
    Cylinder_1: THREE.Mesh;
    Cylinder001: THREE.Mesh;
    Cylinder001_1: THREE.Mesh;
    play: THREE.Mesh;
    Cube: THREE.Mesh;
  };
  materials: {
    grey: THREE.MeshStandardMaterial;
    black: THREE.MeshStandardMaterial;
    blue: THREE.MeshStandardMaterial;
    red: THREE.MeshStandardMaterial;
    darkgrey: THREE.MeshStandardMaterial;
  };
};

type ContextType = Record<
  string,
  React.ForwardRefExoticComponent<JSX.IntrinsicElements["mesh"]>
>;

function Model(props: JSX.IntrinsicElements["group"]) {
  const { nodes, materials } = useGLTF(
    `${process.env.PUBLIC_URL}/Models/boombox.glb`
  ) as GLTFResult;

  const [song, setSong] = useState<HTMLAudioElement>();
  const [isOn, setIsOn] = useState(false);

  const playRef = useRef<THREE.Mesh>(null!);
  const pauseRef = useRef<THREE.Mesh>(null!);

  const [animate, setAnimate] = useState(false);

  const song3 = new Audio(`${process.env.PUBLIC_URL}/audio/Danse.mp3`);

  const playAudio = (event: ThreeEvent<MouseEvent>) => {
    if (isOn) {
      return;
    } else if (song) {
      song?.play();
      playRef.current.position.x += -0.03;
      pauseRef.current.position.x += 0.04;
      setAnimate(true);
      setIsOn(true);
      console.log(song.src);
      if (song.src.toString().includes("Danse")) {
        window.localStorage.setItem("Listen", "complete");
        window.dispatchEvent(new Event("storage"));
      }
    } else {
      swal("Please select a song first!");
    }
  };

  window.addEventListener("storage", () => {
    const currentSrc = window.localStorage.getItem("song");
    const currentSong = new Audio(
      `${process.env.PUBLIC_URL}/audio/${currentSrc}.mp3`
    );
    setSong(currentSong);

    if (isOn) {
      pauseAudio();
      playRef.current.position.x += -0.03;
      pauseRef.current.position.x += 0.04;
    }
  });

  const pauseAudio = () => {
    if (!isOn) {
      return;
    }
    song?.pause();
    playRef.current.position.x += 0.03;
    pauseRef.current.position.x += -0.04;
    setAnimate(false);
    setIsOn(false);
  };

  const boomBoxRef = useRef<THREE.Group>(null);
  useFrame(({ clock }) => {
    if (animate) {
      // Calculate the new position based on the sine function to make it bounce
      const yPosition = 2.85 + Math.sin(clock.getElapsedTime() * 40) * 0.01;

      // Update the position of the mesh
      if (boomBoxRef.current) {
        (boomBoxRef.current as THREE.Group).position.y = yPosition;
      }
    }
  });

  return (
    <group
      {...props}
      dispose={null}
      scale={0.5}
      position={[-3, 2.85, 7.1]}
      rotation={[0, Math.PI / 2, 0]}
      ref={boomBoxRef}
    >
      <group position={[2.469, 1.367, 0]}>
        <mesh geometry={nodes.Cube_1.geometry} material={materials.grey} />
        <mesh geometry={nodes.Cube_2.geometry} material={materials.black} />
        <mesh
          geometry={nodes.Cube_3.geometry}
          material={materials.blue}
          onClick={playAudio}
          onPointerEnter={cursorActiveHandler}
          onPointerLeave={cursorInactiveHandler}
          onPointerOut={cursorInactiveHandler}
          onPointerOver={cursorActiveHandler}
        />
        <mesh
          geometry={nodes.Cube_4.geometry}
          material={materials.red}
          onClick={pauseAudio}
          onPointerEnter={cursorActiveHandler}
          onPointerLeave={cursorInactiveHandler}
          onPointerOut={cursorInactiveHandler}
          onPointerOver={cursorActiveHandler}
        />
        <mesh geometry={nodes.Cube_5.geometry} material={materials.darkgrey} />
      </group>
      <group
        position={[2.872, 1.038, -1.208]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={0.547}
      >
        <mesh geometry={nodes.Circle.geometry} material={materials.grey} />
        <mesh
          geometry={nodes.Circle_1.geometry}
          material={materials.darkgrey}
        />
        <mesh geometry={nodes.Circle_2.geometry} material={materials.black} />
      </group>
      <group
        position={[2.916, 1.866, 0.208]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[0.07, 0.036, 0.07]}
      >
        <mesh
          geometry={nodes.Cylinder.geometry}
          material={materials.darkgrey}
        />
        <mesh geometry={nodes.Cylinder_1.geometry} material={materials.grey} />
      </group>
      <group
        position={[2.313, 2.675, 0.233]}
        rotation={[Math.PI / 2, 0.337, 0]}
        scale={[0.092, 1.477, 0.092]}
      >
        <mesh geometry={nodes.Cylinder001.geometry} material={materials.red} />
        <mesh
          geometry={nodes.Cylinder001_1.geometry}
          material={materials.grey}
        />
      </group>
      <mesh
        geometry={nodes.play.geometry}
        material={materials.darkgrey}
        position={[2.896, 0.844, 0.458]}
        rotation={[2.356, 0, 0]}
        scale={0.045}
        ref={playRef}
      />
      <mesh
        geometry={nodes.Cube.geometry}
        material={materials.darkgrey}
        position={[2.837, 0.845, -0.419]}
        scale={[0.066, 0.066, 0.021]}
        ref={pauseRef}
      />
    </group>
  );
}

useGLTF.preload(`${process.env.PUBLIC_URL}/Models/boombox.glb`);

export { Model as Boombox };
